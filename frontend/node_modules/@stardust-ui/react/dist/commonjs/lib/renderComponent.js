"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _isEmpty2 = _interopRequireDefault(require("lodash/isEmpty"));

var _isNil2 = _interopRequireDefault(require("lodash/isNil"));

var _classnames = _interopRequireDefault(require("classnames"));

var React = _interopRequireWildcard(require("react"));

var _callable = _interopRequireDefault(require("./callable"));

var _getClasses = _interopRequireDefault(require("./getClasses"));

var _getElementType = _interopRequireDefault(require("./getElementType"));

var _getUnhandledProps = _interopRequireDefault(require("./getUnhandledProps"));

var _providerMissingHandler = _interopRequireDefault(require("./providerMissingHandler"));

var _types = require("./accessibility/types");

var _getKeyDownHandlers = _interopRequireDefault(require("./getKeyDownHandlers"));

var _mergeThemes = require("./mergeThemes");

var _FocusZone = require("./accessibility/FocusZone");

var _focusUtilities = require("./accessibility/FocusZone/focusUtilities");

var _createAnimationStyles = _interopRequireDefault(require("./createAnimationStyles"));

var _debug = _interopRequireWildcard(require("./debug"));

var emptyBehavior = {
  attributes: {},
  keyHandlers: {}
};

var getAccessibility = function getAccessibility(props, actionHandlers, isRtlEnabled) {
  var accessibility = props.accessibility;

  if ((0, _isNil2.default)(accessibility)) {
    return emptyBehavior;
  }

  var definition = accessibility(props);
  var keyHandlers = (0, _getKeyDownHandlers.default)(actionHandlers, definition.keyActions, isRtlEnabled);
  return Object.assign({}, emptyBehavior, definition, {
    keyHandlers: keyHandlers
  });
};
/**
 * This function provides compile-time type checking for the following:
 * - if FocusZone implements FocusZone interface,
 * - if FocusZone properties extend FocusZoneProps, and
 * - if the passed properties extend FocusZoneProps.
 *
 * Should the FocusZone implementation change at any time, this function should provide a compile-time guarantee
 * that the new implementation is backwards compatible with the old implementation.
 */


function wrapInGenericFocusZone(FocusZone, props, children) {
  props[_focusUtilities.FOCUSZONE_WRAP_ATTRIBUTE] = true;
  return React.createElement(FocusZone, props, children);
}

var renderWithFocusZone = function renderWithFocusZone(render, focusZoneDefinition, config) {
  if (focusZoneDefinition.mode === _types.FocusZoneMode.Wrap) {
    return wrapInGenericFocusZone(_FocusZone.FocusZone, Object.assign({}, focusZoneDefinition.props, {
      isRtl: config.rtl
    }), render(config));
  }

  if (focusZoneDefinition.mode === _types.FocusZoneMode.Embed) {
    var originalElementType = config.ElementType;
    config.ElementType = _FocusZone.FocusZone;
    config.unhandledProps = Object.assign({}, config.unhandledProps, focusZoneDefinition.props);
    config.unhandledProps.as = originalElementType;
    config.unhandledProps.isRtl = config.rtl;
  }

  return render(config);
};

var _resolveStyles = function resolveStyles(styles, styleParam) {
  return Object.keys(styles).reduce(function (acc, next) {
    return Object.assign({}, acc, (0, _defineProperty2.default)({}, next, (0, _callable.default)(styles[next])(styleParam)));
  }, {});
};

var renderComponent = function renderComponent(config, context) {
  var className = config.className,
      defaultProps = config.defaultProps,
      displayName = config.displayName,
      handledProps = config.handledProps,
      props = config.props,
      state = config.state,
      actionHandlers = config.actionHandlers,
      render = config.render,
      _config$saveDebug = config.saveDebug,
      saveDebug = _config$saveDebug === void 0 ? function () {} : _config$saveDebug;

  if ((0, _isEmpty2.default)(context)) {
    (0, _providerMissingHandler.default)();
  }

  var _ref = context || {},
      _ref$disableAnimation = _ref.disableAnimations,
      disableAnimations = _ref$disableAnimation === void 0 ? false : _ref$disableAnimation,
      _ref$renderer = _ref.renderer,
      renderer = _ref$renderer === void 0 ? null : _ref$renderer,
      _ref$rtl = _ref.rtl,
      rtl = _ref$rtl === void 0 ? false : _ref$rtl,
      _ref$theme = _ref.theme,
      theme = _ref$theme === void 0 ? _mergeThemes.emptyTheme : _ref$theme;

  var ElementType = (0, _getElementType.default)({
    defaultProps: defaultProps
  }, props);
  var stateAndProps = Object.assign({}, state, props); // Resolve variables for this component, allow props.variables to override

  var resolvedVariables = (0, _mergeThemes.mergeComponentVariables)(theme.componentVariables[displayName], props.variables)(theme.siteVariables);
  var animationCSSProp = props.animation ? (0, _createAnimationStyles.default)(props.animation, context.theme) : {}; // Resolve styles using resolved variables, merge results, allow props.styles to override

  var mergedStyles = (0, _mergeThemes.mergeComponentStyles)(theme.componentStyles[displayName], {
    root: props.design
  }, {
    root: props.styles
  }, {
    root: animationCSSProp
  });
  var accessibility = getAccessibility(stateAndProps, actionHandlers, rtl);
  var unhandledProps = (0, _getUnhandledProps.default)({
    handledProps: handledProps
  }, props);
  var styleParam = {
    displayName: displayName,
    props: stateAndProps,
    variables: resolvedVariables,
    theme: theme,
    rtl: rtl,
    disableAnimations: disableAnimations
  };

  var resolvedStyles = _resolveStyles(mergedStyles, styleParam);

  var classes = renderer ? (0, _getClasses.default)(renderer, mergedStyles, styleParam) : {};
  classes.root = (0, _classnames.default)(className, classes.root, props.className);
  var resolvedConfig = {
    ElementType: ElementType,
    unhandledProps: unhandledProps,
    classes: classes,
    variables: resolvedVariables,
    styles: resolvedStyles,
    accessibility: accessibility,
    rtl: rtl,
    theme: theme
  };

  if (accessibility.focusZone) {
    return renderWithFocusZone(render, accessibility.focusZone, resolvedConfig);
  } // conditionally add sources for evaluating debug information to component


  if (_debug.isEnabled) {
    saveDebug(new _debug.default({
      componentName: displayName,
      themes: context ? context.originalThemes : [],
      instanceStylesOverrides: props.styles,
      instanceVariablesOverrides: props.variables,
      resolveStyles: function resolveStyles(styles) {
        return _resolveStyles(styles, styleParam);
      },
      resolveVariables: function resolveVariables(variables) {
        return (0, _callable.default)(variables)(theme.siteVariables);
      }
    }));
  }

  return render(resolvedConfig);
};

var _default = renderComponent;
exports.default = _default;