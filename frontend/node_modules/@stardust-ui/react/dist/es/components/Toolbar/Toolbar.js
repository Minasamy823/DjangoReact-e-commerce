import _extends from "@babel/runtime/helpers/esm/extends";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";
import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _some from "lodash/some";
import _isNil from "lodash/isNil";
import _get from "lodash/get";
import _map from "lodash/map";
import * as React from 'react';
import * as customPropTypes from '@stardust-ui/react-proptypes';
import cx from 'classnames';
import ReactResizeDetector from 'react-resize-detector';
import { Ref } from '@stardust-ui/react-component-ref';
import { childrenExist, createShorthandFactory, UIComponent, commonPropTypes, applyAccessibilityKeyHandlers } from '../../lib';
import { mergeComponentVariables } from '../../lib/mergeThemes';
import { toolbarBehavior, toggleButtonBehavior } from '../../lib/accessibility';
import { withSafeTypeForAs } from '../../types';
import ToolbarCustomItem from './ToolbarCustomItem';
import ToolbarDivider from './ToolbarDivider';
import ToolbarItem from './ToolbarItem';
import ToolbarMenu from './ToolbarMenu';
import ToolbarMenuDivider from './ToolbarMenuDivider';
import ToolbarMenuItem from './ToolbarMenuItem';
import ToolbarRadioGroup from './ToolbarRadioGroup';
import Box from '../Box/Box';
import * as PropTypes from 'prop-types';

var Toolbar =
/*#__PURE__*/
function (_UIComponent) {
  _inherits(Toolbar, _UIComponent);

  function Toolbar() {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, Toolbar);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Toolbar)).call.apply(_getPrototypeOf2, [this].concat(args)));

    _defineProperty(_assertThisInitialized(_this), "state", {
      initialItems: [],
      currentItems: [],
      stable: false
    });

    _defineProperty(_assertThisInitialized(_this), "wrapperRef", React.createRef());

    _defineProperty(_assertThisInitialized(_this), "hiddenToolbarRef", React.createRef());

    _defineProperty(_assertThisInitialized(_this), "animationFrameId", void 0);

    _defineProperty(_assertThisInitialized(_this), "handleItemOverrides", function (variables) {
      return function (predefinedProps) {
        return {
          variables: mergeComponentVariables(variables, predefinedProps.variables)
        };
      };
    });

    _defineProperty(_assertThisInitialized(_this), "onResize", function (newWidth, newHeight) {
      _this.setState(function (_ref) {
        var initialItems = _ref.initialItems;
        return {
          currentItems: initialItems,
          stable: false
        };
      });
    });

    return _this;
  }

  _createClass(Toolbar, [{
    key: "renderItems",
    value: function renderItems(items, variables) {
      var itemOverridesFn = this.handleItemOverrides(variables);
      return _map(items, function (item) {
        var kind = _get(item, 'kind', 'item');

        switch (kind) {
          case 'divider':
            return ToolbarDivider.create(item, {
              overrideProps: itemOverridesFn
            });

          case 'group':
            return ToolbarRadioGroup.create(item, {
              overrideProps: itemOverridesFn
            });

          case 'toggle':
            return ToolbarItem.create(item, {
              defaultProps: {
                accessibility: toggleButtonBehavior
              },
              overrideProps: itemOverridesFn
            });

          case 'custom':
            return ToolbarCustomItem.create(item, {
              overrideProps: itemOverridesFn
            });

          default:
            return ToolbarItem.create(item, {
              overrideProps: itemOverridesFn
            });
        }
      });
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      this.afterComponentRendered();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.afterComponentRendered();
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.animationFrameId !== undefined) {
        window.cancelAnimationFrame(this.animationFrameId);
        this.animationFrameId = undefined;
      }
    }
  }, {
    key: "afterComponentRendered",
    value: function afterComponentRendered() {
      var _this2 = this;

      if (this.animationFrameId !== undefined) {
        window.cancelAnimationFrame(this.animationFrameId);
      }

      this.animationFrameId = window.requestAnimationFrame(function () {
        _this2.animationFrameId = undefined;
        var onReduceItems = _this2.props.onReduceItems;

        if (_isNil(onReduceItems) || !_this2.hiddenToolbarRef.current || _this2.state.stable) {
          return;
        }

        var _this2$measureOverflo = _this2.measureOverflow(),
            fits = _this2$measureOverflo.fits,
            measures = _this2$measureOverflo.measures;

        _this2.setState(function (_ref2) {
          var stable = _ref2.stable,
              currentItems = _ref2.currentItems;

          if (fits) {
            return {
              stable: true,
              stableItems: currentItems,
              currentItems: currentItems
            };
          }

          var reducedItems = onReduceItems(currentItems, measures);

          if (reducedItems === null) {
            return {
              stable: true,
              stableItems: currentItems,
              currentItems: currentItems
            };
          }

          return {
            stable: stable,
            currentItems: reducedItems
          };
        });
      });
    }
  }, {
    key: "measureOverflow",
    value: function measureOverflow() {
      var wrapperRect = this.wrapperRef.current.getBoundingClientRect();
      var hiddenToolbarElement = this.hiddenToolbarRef.current;

      var measures = _map(hiddenToolbarElement.children, function (child) {
        var rect = child.getBoundingClientRect();
        return {
          left: rect.left,
          leftFits: rect.left >= wrapperRect.left,
          right: rect.right,
          rightFits: rect.right <= wrapperRect.right
        };
      });

      var fits = !_some(measures, function (c) {
        return !c.leftFits || !c.rightFits;
      });
      return {
        fits: fits,
        measures: measures
      };
    }
  }, {
    key: "renderComponent",
    value: function renderComponent(_ref3) {
      var _this3 = this;

      var accessibility = _ref3.accessibility,
          ElementType = _ref3.ElementType,
          classes = _ref3.classes,
          variables = _ref3.variables,
          unhandledProps = _ref3.unhandledProps;
      var _this$props = this.props,
          children = _this$props.children,
          items = _this$props.items,
          onReduceItems = _this$props.onReduceItems,
          measurement = _this$props.measurement,
          wrapper = _this$props.wrapper;

      if (!_isNil(onReduceItems)) {
        return React.createElement(Ref, {
          innerRef: this.wrapperRef
        }, Box.create(wrapper, {
          defaultProps: Object.assign({
            className: cx(Toolbar.slotClassNames.wrapper, classes.wrapper)
          }, accessibility.attributes.wrapper, applyAccessibilityKeyHandlers(accessibility.keyHandlers.wrapper, wrapper)),
          overrideProps: function overrideProps() {
            return {
              children: React.createElement(React.Fragment, null, !_this3.state.stable && Box.create(measurement, {
                defaultProps: Object.assign({
                  className: cx(Toolbar.slotClassNames.measurement, classes.measurement)
                }, accessibility.attributes.measurement, applyAccessibilityKeyHandlers(accessibility.keyHandlers.measurement, wrapper)),
                overrideProps: function overrideProps() {
                  return {
                    children: React.createElement(Ref, {
                      innerRef: _this3.hiddenToolbarRef
                    }, React.createElement(ElementType, _extends({
                      className: classes.root
                    }, accessibility.attributes.root, unhandledProps), _this3.renderItems(_this3.state.currentItems, variables)))
                  };
                }
              }), _this3.state.stableItems && React.createElement(ElementType, _extends({
                className: classes.root
              }, accessibility.attributes.root, unhandledProps), _this3.renderItems(_this3.state.stableItems, variables)), React.createElement(ReactResizeDetector, {
                xskipOnMount: true,
                handleWidth: true,
                onResize: _this3.onResize
              }))
            };
          }
        }));
      }

      return React.createElement(ElementType, _extends({
        className: classes.root
      }, accessibility.attributes.root, unhandledProps), childrenExist(children) ? children : this.renderItems(items, variables));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(props, state) {
      if (props.items === state.initialItems) {
        return null;
      }

      return {
        initialItems: props.items,
        currentItems: props.items,
        stableItems: state.stableItems,
        stable: false
      };
    }
  }]);

  return Toolbar;
}(UIComponent);

_defineProperty(Toolbar, "create", void 0);

_defineProperty(Toolbar, "className", 'ui-toolbar');

_defineProperty(Toolbar, "slotClassNames", {
  wrapper: "".concat(Toolbar.className, "__wrapper"),
  measurement: "".concat(Toolbar.className, "__measurement")
});

_defineProperty(Toolbar, "displayName", 'Toolbar');

_defineProperty(Toolbar, "propTypes", Object.assign({}, commonPropTypes.createCommon(), {
  items: customPropTypes.collectionShorthandWithKindProp(['divider', 'item', 'group', 'toggle', 'custom']),
  onReduceItems: PropTypes.func,
  measurement: customPropTypes.itemShorthand,
  wrapper: customPropTypes.itemShorthand
}));

_defineProperty(Toolbar, "defaultProps", {
  accessibility: toolbarBehavior,
  measurement: {},
  wrapper: {}
});

_defineProperty(Toolbar, "CustomItem", ToolbarCustomItem);

_defineProperty(Toolbar, "Divider", ToolbarDivider);

_defineProperty(Toolbar, "Item", ToolbarItem);

_defineProperty(Toolbar, "Menu", ToolbarMenu);

_defineProperty(Toolbar, "MenuDivider", ToolbarMenuDivider);

_defineProperty(Toolbar, "MenuItem", ToolbarMenuItem);

_defineProperty(Toolbar, "RadioGroup", ToolbarRadioGroup);

Toolbar.create = createShorthandFactory({
  Component: Toolbar,
  mappedProp: 'content'
});
/**
 * A Toolbar is a container for grouping a set of controls, often action controls (e.g. buttons) or input controls (e.g. checkboxes).
 *
 * @accessibility
 *  * Implements [ARIA Toolbar](https://www.w3.org/TR/wai-aria-practices-1.1/#toolbar) design pattern.
 * @accessibilityIssues
 * [Issue 988424: VoiceOver narrates selected for button in toolbar](https://bugs.chromium.org/p/chromium/issues/detail?id=988424)
 */

export default withSafeTypeForAs(Toolbar);