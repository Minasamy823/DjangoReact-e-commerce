import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _isEmpty from "lodash/isEmpty";
import _isNil from "lodash/isNil";
import cx from 'classnames';
import * as React from 'react';
import callable from './callable';
import getClasses from './getClasses';
import getElementType from './getElementType';
import getUnhandledProps from './getUnhandledProps';
import logProviderMissingWarning from './providerMissingHandler';
import { FocusZoneMode } from './accessibility/types';
import getKeyDownHandlers from './getKeyDownHandlers';
import { emptyTheme, mergeComponentStyles, mergeComponentVariables } from './mergeThemes';
import { FocusZone } from './accessibility/FocusZone';
import { FOCUSZONE_WRAP_ATTRIBUTE } from './accessibility/FocusZone/focusUtilities';
import createAnimationStyles from './createAnimationStyles';
import Debug, { isEnabled as isDebugEnabled } from './debug';
var emptyBehavior = {
  attributes: {},
  keyHandlers: {}
};

var getAccessibility = function getAccessibility(props, actionHandlers, isRtlEnabled) {
  var accessibility = props.accessibility;

  if (_isNil(accessibility)) {
    return emptyBehavior;
  }

  var definition = accessibility(props);
  var keyHandlers = getKeyDownHandlers(actionHandlers, definition.keyActions, isRtlEnabled);
  return Object.assign({}, emptyBehavior, definition, {
    keyHandlers: keyHandlers
  });
};
/**
 * This function provides compile-time type checking for the following:
 * - if FocusZone implements FocusZone interface,
 * - if FocusZone properties extend FocusZoneProps, and
 * - if the passed properties extend FocusZoneProps.
 *
 * Should the FocusZone implementation change at any time, this function should provide a compile-time guarantee
 * that the new implementation is backwards compatible with the old implementation.
 */


function wrapInGenericFocusZone(FocusZone, props, children) {
  props[FOCUSZONE_WRAP_ATTRIBUTE] = true;
  return React.createElement(FocusZone, props, children);
}

var renderWithFocusZone = function renderWithFocusZone(render, focusZoneDefinition, config) {
  if (focusZoneDefinition.mode === FocusZoneMode.Wrap) {
    return wrapInGenericFocusZone(FocusZone, Object.assign({}, focusZoneDefinition.props, {
      isRtl: config.rtl
    }), render(config));
  }

  if (focusZoneDefinition.mode === FocusZoneMode.Embed) {
    var originalElementType = config.ElementType;
    config.ElementType = FocusZone;
    config.unhandledProps = Object.assign({}, config.unhandledProps, focusZoneDefinition.props);
    config.unhandledProps.as = originalElementType;
    config.unhandledProps.isRtl = config.rtl;
  }

  return render(config);
};

var _resolveStyles = function resolveStyles(styles, styleParam) {
  return Object.keys(styles).reduce(function (acc, next) {
    return Object.assign({}, acc, _defineProperty({}, next, callable(styles[next])(styleParam)));
  }, {});
};

var renderComponent = function renderComponent(config, context) {
  var className = config.className,
      defaultProps = config.defaultProps,
      displayName = config.displayName,
      handledProps = config.handledProps,
      props = config.props,
      state = config.state,
      actionHandlers = config.actionHandlers,
      render = config.render,
      _config$saveDebug = config.saveDebug,
      saveDebug = _config$saveDebug === void 0 ? function () {} : _config$saveDebug;

  if (_isEmpty(context)) {
    logProviderMissingWarning();
  }

  var _ref = context || {},
      _ref$disableAnimation = _ref.disableAnimations,
      disableAnimations = _ref$disableAnimation === void 0 ? false : _ref$disableAnimation,
      _ref$renderer = _ref.renderer,
      renderer = _ref$renderer === void 0 ? null : _ref$renderer,
      _ref$rtl = _ref.rtl,
      rtl = _ref$rtl === void 0 ? false : _ref$rtl,
      _ref$theme = _ref.theme,
      theme = _ref$theme === void 0 ? emptyTheme : _ref$theme;

  var ElementType = getElementType({
    defaultProps: defaultProps
  }, props);
  var stateAndProps = Object.assign({}, state, props); // Resolve variables for this component, allow props.variables to override

  var resolvedVariables = mergeComponentVariables(theme.componentVariables[displayName], props.variables)(theme.siteVariables);
  var animationCSSProp = props.animation ? createAnimationStyles(props.animation, context.theme) : {}; // Resolve styles using resolved variables, merge results, allow props.styles to override

  var mergedStyles = mergeComponentStyles(theme.componentStyles[displayName], {
    root: props.design
  }, {
    root: props.styles
  }, {
    root: animationCSSProp
  });
  var accessibility = getAccessibility(stateAndProps, actionHandlers, rtl);
  var unhandledProps = getUnhandledProps({
    handledProps: handledProps
  }, props);
  var styleParam = {
    displayName: displayName,
    props: stateAndProps,
    variables: resolvedVariables,
    theme: theme,
    rtl: rtl,
    disableAnimations: disableAnimations
  };

  var resolvedStyles = _resolveStyles(mergedStyles, styleParam);

  var classes = renderer ? getClasses(renderer, mergedStyles, styleParam) : {};
  classes.root = cx(className, classes.root, props.className);
  var resolvedConfig = {
    ElementType: ElementType,
    unhandledProps: unhandledProps,
    classes: classes,
    variables: resolvedVariables,
    styles: resolvedStyles,
    accessibility: accessibility,
    rtl: rtl,
    theme: theme
  };

  if (accessibility.focusZone) {
    return renderWithFocusZone(render, accessibility.focusZone, resolvedConfig);
  } // conditionally add sources for evaluating debug information to component


  if (isDebugEnabled) {
    saveDebug(new Debug({
      componentName: displayName,
      themes: context ? context.originalThemes : [],
      instanceStylesOverrides: props.styles,
      instanceVariablesOverrides: props.variables,
      resolveStyles: function resolveStyles(styles) {
        return _resolveStyles(styles, styleParam);
      },
      resolveVariables: function resolveVariables(variables) {
        return callable(variables)(theme.siteVariables);
      }
    }));
  }

  return render(resolvedConfig);
};

export default renderComponent;